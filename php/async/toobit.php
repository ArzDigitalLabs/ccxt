<?php

namespace ccxt\async;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\async\abstract\toobit as Exchange;
use \React\Async;
use \React\Promise\PromiseInterface;

class toobit extends Exchange {

    public function describe(): mixed {
        return $this->deep_extend(parent::describe(), array(
            'id' => 'toobit',
            'name' => 'Toobit',
            'countries' => array( 'KY' ), // Cayman Islands
            'rateLimit' => 1000,
            'version' => '1',
            'certified' => false,
            'pro' => false,
            'has' => array(
                'CORS' => null,
                'spot' => true,
                'margin' => false,
                'swap' => true,
                'future' => false,
                'option' => false,
                'addMargin' => false,
                'cancelAllOrders' => false,
                'cancelOrder' => false,
                'cancelOrders' => false,
                'createDepositAddress' => false,
                'createOrder' => false,
                'createStopLimitOrder' => false,
                'createStopMarketOrder' => false,
                'createStopOrder' => false,
                'editOrder' => false,
                'fetchBalance' => false,
                'fetchBorrowInterest' => false,
                'fetchBorrowRateHistories' => false,
                'fetchBorrowRateHistory' => false,
                'fetchClosedOrders' => false,
                'fetchCrossBorrowRate' => false,
                'fetchCrossBorrowRates' => false,
                'fetchCurrencies' => false,
                'fetchDepositAddress' => false,
                'fetchDeposits' => false,
                'fetchFundingHistory' => false,
                'fetchFundingRate' => false,
                'fetchFundingRateHistory' => false,
                'fetchFundingRates' => false,
                'fetchIndexOHLCV' => false,
                'fetchIsolatedBorrowRate' => false,
                'fetchIsolatedBorrowRates' => false,
                'fetchL2OrderBook' => false,
                'fetchLedger' => false,
                'fetchLedgerEntry' => false,
                'fetchLeverageTiers' => false,
                'fetchMarkets' => true,
                'fetchMarkOHLCV' => false,
                'fetchMyTrades' => false,
                'fetchOHLCV' => true,
                'fetchOpenInterestHistory' => false,
                'fetchOpenOrders' => false,
                'fetchOrder' => false,
                'fetchOrderBook' => true,
                'fetchOrders' => false,
                'fetchOrderTrades' => 'emulated',
                'fetchPositions' => false,
                'fetchPremiumIndexOHLCV' => false,
                'fetchTicker' => true,
                'fetchTickers' => true,
                'fetchTime' => false,
                'fetchTrades' => false,
                'fetchTradingFee' => false,
                'fetchTradingFees' => false,
                'fetchWithdrawals' => false,
                'setLeverage' => false,
                'setMarginMode' => false,
                'transfer' => false,
                'withdraw' => false,
            ),
            'comment' => 'This comment is optional',
            'urls' => array(
                'logo' => 'https://toobit-docs.github.io/apidocs/spot/v1/en/images/logo.svg',
                'api' => array(
                    'public' => 'https://api.toobit.com',
                ),
                'www' => 'https://www.toobit.com/',
                'doc' => array(
                    'https://toobit-docs.github.io/apidocs/spot/v1/en/#change-log',
                ),
            ),
            'timeframes' => array(
                '1m' => '1m',
                '3m' => '3m',
                '5m' => '5m',
                '15m' => '15m',
                '30m' => '30m',
                '1h' => '1h',
                '2h' => '2h',
                '4h' => '4h',
                '6h' => '6h',
                '12h' => '12h',
                '1d' => '1d',
                '1w' => '1w',
                '1M' => '1M',
            ),
            'api' => array(
                'public' => array(
                    'get' => array(
                        'quote/v1/ticker/24hr' => 1,
                        'quote/v1/klines' => 1,
                        '/api/v1/exchangeInfo' => 1,
                    ),
                ),
            ),
            'fees' => array(
                'trading' => array(
                    'tierBased' => false,
                    'percentage' => true,
                    'maker' => $this->parse_number('0.001'),
                    'taker' => $this->parse_number('0.001'),
                ),
            ),
        ));
    }

    public function fetch_markets($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * retrieves data on all markets for toobit
             * @see https://api.toobit.com/api/v1/exchangeInfo
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} an array of objects representing $market data
             */
            $response = Async\await($this->publicGetApiV1ExchangeInfo ());
            $symbols = $this->safe_value($response, 'symbols', array());
            $result = array();
            for ($i = 0; $i < count($symbols); $i++) {
                $symbolData = $symbols[$i];
                $status = $this->safe_value($symbolData, 'status');
                $symbol = $this->safe_value($symbolData, 'symbol');
                if ($status !== 'TRADING' || $symbol === 'TESTA1S3TESTX8Z9') {
                    continue;
                }
                $market = $this->parse_market($symbolData);
                $result[] = $market;
            }
            return $result;
        }) ();
    }

    public function parse_market($market): array {
        //         {
        //             "filters" => array(
        //                 array(
        //                     "minPrice" => "0.01",
        //                     "maxPrice" => "10000000.00000000",
        //                     "tickSize" => "0.01",
        //                     "filterType" => "PRICE_FILTER"
        //                 ),
        //                 array(
        //                     "minQty" => "0.0001",
        //                     "maxQty" => "4000",
        //                     "stepSize" => "0.0001",
        //                     "filterType" => "LOT_SIZE"
        //                 ),
        //                 {
        //                     "minNotional" => "5",
        //                     "filterType" => "MIN_NOTIONAL"
        //                 }
        //             ),
        //             "exchangeId" => "301",
        //             "symbol" => "ETHUSDT",
        //             "symbolName" => "ETHUSDT",
        //             "status" => "TRADING",
        //             "baseAsset" => "ETH",
        //             "baseAssetName" => "ETH",
        //             "baseAssetPrecision" => "0.0001",
        //             "quoteAsset" => "USDT",
        //             "quoteAssetName" => "USDT",
        //             "quotePrecision" => "0.01",
        //             "icebergAllowed" => false,
        //             "isAggregate" => false,
        //             "allowMargin" => true
        //         }
        $symbol = $this->safe_value($market, 'symbol');
        $baseAsset = $this->safe_value($market, 'baseAsset');
        $quoteAsset = $this->safe_value($market, 'quoteAsset');
        $baseAssetPrecision = $this->safe_value($market, 'baseAssetPrecision');
        $quotePrecision = $this->safe_value($market, 'quotePrecision');
        $allowMargin = $this->safe_value($market, 'allowMargin', false);
        $filters = $this->safe_value($market, 'filters', array());
        // Parse $filters to extract limits and precision
        $minPrice = null;
        $maxPrice = null;
        $tickSize = null;
        $minQty = null;
        $maxQty = null;
        $stepSize = null;
        $minNotional = null;
        $minAmount = null;
        $maxAmount = null;
        for ($i = 0; $i < count($filters); $i++) {
            $filter = $filters[$i];
            $filterType = $this->safe_value($filter, 'filterType');
            if ($filterType === 'PRICE_FILTER') {
                $minPrice = $this->safe_number($filter, 'minPrice');
                $maxPrice = $this->safe_number($filter, 'maxPrice');
                $tickSize = $this->safe_number($filter, 'tickSize');
            } elseif ($filterType === 'LOT_SIZE') {
                $minQty = $this->safe_number($filter, 'minQty');
                $maxQty = $this->safe_number($filter, 'maxQty');
                $stepSize = $this->safe_number($filter, 'stepSize');
            } elseif ($filterType === 'MIN_NOTIONAL') {
                $minNotional = $this->safe_number($filter, 'minNotional');
            } elseif ($filterType === 'TRADE_AMOUNT') {
                $minAmount = $this->safe_number($filter, 'minAmount');
                $maxAmount = $this->safe_number($filter, 'maxAmount');
            }
        }
        $id = $symbol;
        $base = $this->safe_currency_code($baseAsset);
        $quote = $this->safe_currency_code($quoteAsset);
        $baseId = strtolower($baseAsset);
        $quoteId = strtolower($quoteAsset);
        // Calculate precision from step sizes and precision strings
        $amountPrecision = $stepSize ? (string) $this->precision_from_string($stepSize) : $this->precision_from_string($baseAssetPrecision);
        $pricePrecision = $tickSize ? (string) $this->precision_from_string($tickSize) : $this->precision_from_string($quotePrecision);
        return array(
            'id' => $id,
            'symbol' => $base . '/' . $quote,
            'base' => $base,
            'quote' => $quote,
            'settle' => null,
            'baseId' => $baseId,
            'quoteId' => $quoteId,
            'settleId' => null,
            'type' => 'spot',
            'spot' => true,
            'margin' => $allowMargin,
            'swap' => false,
            'future' => false,
            'option' => false,
            'active' => true,
            'contract' => false,
            'linear' => null,
            'inverse' => null,
            'contractSize' => null,
            'expiry' => null,
            'expiryDatetime' => null,
            'strike' => null,
            'optionType' => null,
            'precision' => array(
                'amount' => $amountPrecision,
                'price' => $pricePrecision,
            ),
            'limits' => array(
                'leverage' => array(
                    'min' => null,
                    'max' => null,
                ),
                'amount' => array(
                    'min' => $minQty,
                    'max' => $maxQty,
                ),
                'price' => array(
                    'min' => $minPrice,
                    'max' => $maxPrice,
                ),
                'cost' => array(
                    'min' => $minNotional || $minAmount,
                    'max' => $maxAmount,
                ),
            ),
            'created' => null,
            'info' => $market,
        );
    }

    public function fetch_tickers(?array $symbols = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $params) {
            /**
             * fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
             * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#tickers
             * @param {string[]|null} $symbols unified $symbols of the markets to fetch the $ticker for, all market tickers are returned if not assigned
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a dictionary of ~@link https://docs.ccxt.com/#/?id=$ticker-structure $ticker structures~
             */
            Async\await($this->load_markets());
            if ($symbols !== null) {
                $symbols = $this->market_symbols($symbols);
            }
            $response = Async\await($this->publicGetQuoteV1Ticker24hr ());
            $result = array();
            for ($i = 0; $i < count($response); $i++) {
                $volume = $this->safe_float($response[$i], 'v');
                if ($volume === 0) {
                    continue;
                }
                $ticker = $this->parse_ticker($response[$i]);
                $symbol = $ticker['symbol'];
                $result[$symbol] = $ticker;
            }
            return $this->filter_by_array_tickers($result, 'symbol', $symbols);
        }) ();
    }

    public function fetch_ticker(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * fetches a price $ticker, a statistical calculation with the information calculated over the past 24 hours for a specific $market
             * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#$ticker
             * @param {string} $symbol unified $symbol of the $market to fetch the $ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=$ticker-structure $ticker structure~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'symbol' => $market['id'],
            );
            $response = Async\await($this->publicGetQuoteV1Ticker24hr ($request));
            $ticker = $this->parse_ticker($response[0]);
            return $ticker;
        }) ();
    }

    public function parse_ticker($ticker, ?array $market = null): array {
        //         {
        // t => 1757164008834,
        // s => "BTCUSDT",
        // c => "110895.06",
        // h => "113310.01",
        // l => "110219.01",
        // o => "112951.99",
        // v => "3893.406649",
        // qv => "433374169.27969515",
        // pc => "-2056.93",
        // pcp => "-0.0182"
        // }
        $marketType = 'spot';
        $symbol = $this->safe_value($ticker, 's');
        $marketId = $symbol;
        $symbol = $this->safe_symbol($marketId, $market, null, $marketType);
        $high = $this->safe_float($ticker, 'h');
        $low = $this->safe_float($ticker, 'l');
        $open = $this->safe_float($ticker, 'o');
        $close = $this->safe_float($ticker, 'c');
        $last = $this->safe_float($ticker, 'c');
        $change = $this->safe_float($ticker, 'pcp');
        $priceChange = $this->safe_float($ticker, 'pc');
        $baseVolume = $this->safe_float($ticker, 'v');
        $quoteVolume = $this->safe_float($ticker, 'qv');
        $datetime = $this->safe_string($ticker, 't');
        $bid = $this->safe_float($ticker, 'b', 0);
        $ask = $this->safe_float($ticker, 'a', 0);
        return $this->safe_ticker(array(
            'symbol' => $symbol,
            'timestamp' => $datetime,
            'datetime' => $this->parse8601($datetime),
            'high' => $high,
            'low' => $low,
            'bid' => $bid,
            'bidVolume' => null,
            'ask' => $ask,
            'askVolume' => null,
            'vwap' => null,
            'open' => $open,
            'close' => $close,
            'last' => $last,
            'previousClose' => null,
            'change' => $priceChange,
            'percentage' => $change,
            'average' => null,
            'baseVolume' => $baseVolume,
            'quoteVolume' => $quoteVolume,
            'info' => $ticker,
        ), $market);
    }

    public function fetch_ohlcv(string $symbol, $timeframe = '1h', ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            /**
             * fetches historical candlestick data containing the $open, $high, $low, and $close price, and the $volume of a $market
             * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#chart
             * @param {string} $symbol unified $symbol of the $market to fetch OHLCV data for
             * @param {string} $timeframe the length of time each $candle represents
             * @param {int} [$since] timestamp in ms of the earliest $candle to fetch
             * @param {int} [$limit] the maximum amount of candles to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {int[][]} A list of candles ordered, $open, $high, $low, $close, $volume
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $endTime = Date.now ();
            $request = array(
                'symbol' => $market['id'],
                'from' => ($endTime - (24 * 60 * 60 * 1000)),
                'to' => $endTime,
                'interval' => $this->safe_string($this->timeframes, $timeframe, $timeframe),
            );
            if ($since !== null) {
                $request['from'] = $since;
            }
            if ($timeframe !== null) {
                $request['interval'] = $this->safe_string($this->timeframes, $timeframe, $timeframe);
            }
            $response = Async\await($this->publicGetQuoteV1Klines ($request));
            $ohlcvs = array();
            for ($i = 0; $i < count($response); $i++) {
                $candle = $response[$i];
                $ts = $this->safe_timestamp($candle, 0);
                $open = $this->safe_float($candle, 1);
                $high = $this->safe_float($candle, 2);
                $low = $this->safe_float($candle, 3);
                $close = $this->safe_float($candle, 4);
                $volume = $this->safe_float($candle, 5);
                $ohlcvs[] = array(
                    $ts,
                    $open,
                    $high,
                    $low,
                    $close,
                    $volume,
                );
            }
            return $this->parse_ohlcvs($ohlcvs, $market, $timeframe, $since, $limit);
        }) ();
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $query = $this->omit($params, $this->extract_params($path));
        $url = $this->urls['api']['public'] . '/' . $path;
        if ($path === 'quote/v1/ticker/24hr') {
            $url = $url . '?' . $this->urlencode($query);
        }
        if ($path === 'quote/v1/klines') {
            $url = $url . '?' . $this->urlencode($query);
        }
        $headers = array( 'Content-Type' => 'application/json' );
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }
}
