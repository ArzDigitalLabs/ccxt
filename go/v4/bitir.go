package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type bitir struct {
    Exchange

}

func NewBitirCore() *bitir {
    p := &bitir{}
    setDefaults(p)
    return p
}

func  (this *bitir) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "bitir",
        "name": "Bit.ir",
        "countries": []interface{}{"IR"},
        "rateLimit": 1000,
        "version": "1",
        "certified": false,
        "pro": false,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": false,
            "swap": false,
            "future": false,
            "option": false,
            "addMargin": false,
            "cancelAllOrders": false,
            "cancelOrder": false,
            "cancelOrders": false,
            "createDepositAddress": false,
            "createOrder": false,
            "createStopLimitOrder": false,
            "createStopMarketOrder": false,
            "createStopOrder": false,
            "editOrder": false,
            "fetchBalance": false,
            "fetchBorrowInterest": false,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchClosedOrders": false,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchCurrencies": false,
            "fetchDepositAddress": false,
            "fetchDeposits": false,
            "fetchFundingHistory": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchL2OrderBook": false,
            "fetchLedger": false,
            "fetchLedgerEntry": false,
            "fetchLeverageTiers": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMyTrades": false,
            "fetchOHLCV": true,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrders": false,
            "fetchOrder": false,
            "fetchOrderBook": true,
            "fetchOrders": false,
            "fetchOrderTrades": "emulated",
            "fetchPositions": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTime": false,
            "fetchTrades": false,
            "fetchTradingFee": false,
            "fetchTradingFees": false,
            "fetchWithdrawals": false,
            "setLeverage": false,
            "setMarginMode": false,
            "transfer": false,
            "withdraw": false,
        },
        "comment": "This comment is optional",
        "urls": map[string]interface{} {
            "logo": "https://iranbroker.net/wp-content/uploads/2023/05/bit.ir-logo-png.png",
            "api": map[string]interface{} {
                "public": "https://api.bit.ir",
            },
            "www": "https://www.bit.ir",
            "doc": []interface{}{"https://www.bit.ir"},
        },
        "timeframes": map[string]interface{} {
            "1h": "60",
            "3h": "180",
            "6h": "360",
            "12h": "720",
            "1d": "1D",
            "2d": "2D",
            "3d": "3D",
            "1w": "1W",
            "1M": "1M",
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": map[string]interface{} {
                    "v1/market": 1,
                    "v2/udf/real/history": 1,
                    "v1/market/{id}/order": 1,
                },
            },
        },
        "commonCurrencies": map[string]interface{} {
            "IRR": "IRT",
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "tierBased": false,
                "percentage": true,
                "maker": this.ParseNumber("0.001"),
                "taker": this.ParseNumber("0.001"),
            },
        },
    })
}
func  (this *bitir) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    /**
            * @method
            * @name bitir#fetchMarkets
            * @description retrieves data on all markets for bitir
            * @see https://www.bit.ir/fa
            * @param {object} [params] extra parameters specific to the exchange API endpoint
            * @returns {object[]} an array of objects representing market data
            */
            params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetV1Market())
            PanicOnError(response)
            var markets interface{} = this.SafeList(response, "data")
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(markets)); i++ {
                var market interface{} = this.ParseMarket(GetValue(markets, i))
                AppendToArray(&result, market)
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *bitir) ParseMarket(market interface{}) interface{}  {
    // {
    //     'id': 1,
    //     'uid': 'ec00b2c906039253d62f0f1cf03f0c3c992a3262',
    //     'base_currency': {
    //         'id': 'BTC',
    //         'icon_path': 'https://coins-ir-bit.bit.ir/front-pngs/btc.png',
    //         'name': 'بیت کوین',
    //         'decimal_precision': 8,
    //     },
    //     'quote_currency': {
    //         'id': 'IRR',
    //         'icon_path': 'https://coins-ir-bit.bit.ir/front-pngs/irt.png',
    //         'name': 'تومان',
    //         'decimal_precision': 0,
    //     },
    //     'name': 'بیت کوین - تومان',
    //     'quote_currency_precision': 0,
    //     'base_currency_precision': 8,
    //     'history': [
    //         '39720036590',
    //         '39554414710',
    //         '39749295670',
    //         '39928938500',
    //         '39640942650',
    //         '39658390120',
    //         '39610761890',
    //         '39993818410',
    //         '39864571220',
    //         '39896337660',
    //         '39940417440',
    //         '39886829510',
    //         '39852060060',
    //         '39831320470',
    //         '40060533430',
    //         '40162665220',
    //         '40077517070',
    //         '39867289240',
    //         '39827433250',
    //         '39667574820',
    //         '39699242910',
    //         '39547099850',
    //         '39643401200',
    //         '39619745360',
    //     ],
    //     'min_price': '39351207320',
    //     'max_price': '40209135030',
    //     'last_price': '39619745360',
    //     'last_volume': '12146697437',
    //     'day_change_percent': -0.25,
    //     'week_change_percent': -0.8,
    //     'tradingview_symbol': 'BINANCE:BTCUSDT',
    //     'liked_by_user': false,
    // },
    var baseCurrency interface{} = this.SafeDict(market, "base_currency")
    var quoteCurrency interface{} = this.SafeDict(market, "quote_currency")
    var id interface{} = this.SafeString(market, "id")
    var baseId interface{} = this.SafeString(baseCurrency, "id")
    var quoteId interface{} = this.SafeString(quoteCurrency, "id")
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    baseId = ToLower(baseId)
    quoteId = ToLower(quoteId)
    return map[string]interface{} {
        "id": id,
        "symbol": Add(Add(base, "/"), quote),
        "base": base,
        "quote": quote,
        "settle": nil,
        "baseId": baseId,
        "quoteId": quoteId,
        "settleId": nil,
        "type": "spot",
        "spot": true,
        "margin": false,
        "swap": false,
        "future": false,
        "option": false,
        "active": true,
        "contract": false,
        "linear": nil,
        "inverse": nil,
        "contractSize": nil,
        "expiry": nil,
        "expiryDatetime": nil,
        "strike": nil,
        "optionType": nil,
        "precision": map[string]interface{} {
            "amount": nil,
            "price": nil,
        },
        "limits": map[string]interface{} {
            "leverage": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "amount": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "price": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "cost": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
        },
        "created": nil,
        "info": market,
    }
}
func  (this *bitir) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    /**
            * @method
            * @name bitir#fetchTickers
            * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
            * @see https://www.bit.ir/fa
            * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
            * @param {object} [params] extra parameters specific to the exchange API endpoint
            * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
            */
            symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes2738 := (<-this.LoadMarkets())
            PanicOnError(retRes2738)
            if IsTrue(!IsEqual(symbols, nil)) {
                symbols = this.MarketSymbols(symbols)
            }
        
            response:= (<-this.PublicGetV1Market())
            PanicOnError(response)
            var markets interface{} = this.SafeList(response, "data")
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(markets)); i++ {
        
                ticker:= (<-this.ParseTicker(GetValue(markets, i)))
                PanicOnError(ticker)
                var symbol interface{} = GetValue(ticker, "symbol")
                AddElementToObject(result, symbol, ticker)
            }
        
            ch <- this.FilterByArrayTickers(result, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *bitir) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    /**
            * @method
            * @name bitir#fetchTicker
            * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
            * @see https://www.bit.ir/fa
            * @param {string} symbol unified symbol of the market to fetch the ticker for
            * @param {object} [params] extra parameters specific to the exchange API endpoint
            * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
            */
            params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes2988 := (<-this.LoadMarkets())
            PanicOnError(retRes2988)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "id": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetV1Market(request))
            PanicOnError(response)
            var markets interface{} = this.SafeDict(response, "data")
        
            ticker:= (<-this.ParseTicker(markets))
            PanicOnError(ticker)
        
            ch <- ticker
            return nil
        
            }()
            return ch
        }
func  (this *bitir) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    // {
    //     'id': 1,
    //     'uid': 'ec00b2c906039253d62f0f1cf03f0c3c992a3262',
    //     'base_currency': {
    //         'id': 'BTC',
    //         'icon_path': 'https://coins-ir-bit.bit.ir/front-pngs/btc.png',
    //         'name': 'بیت کوین',
    //         'decimal_precision': 8,
    //     },
    //     'quote_currency': {
    //         'id': 'IRR',
    //         'icon_path': 'https://coins-ir-bit.bit.ir/front-pngs/irt.png',
    //         'name': 'تومان',
    //         'decimal_precision': 0,
    //     },
    //     'name': 'بیت کوین - تومان',
    //     'quote_currency_precision': 0,
    //     'base_currency_precision': 8,
    //     'history': [
    //         '39720036590',
    //         '39554414710',
    //         '39749295670',
    //         '39928938500',
    //         '39640942650',
    //         '39658390120',
    //         '39610761890',
    //         '39993818410',
    //         '39864571220',
    //         '39896337660',
    //         '39940417440',
    //         '39886829510',
    //         '39852060060',
    //         '39831320470',
    //         '40060533430',
    //         '40162665220',
    //         '40077517070',
    //         '39867289240',
    //         '39827433250',
    //         '39667574820',
    //         '39699242910',
    //         '39547099850',
    //         '39643401200',
    //         '39619745360',
    //     ],
    //     'min_price': '39351207320',
    //     'max_price': '40209135030',
    //     'last_price': '39619745360',
    //     'last_volume': '12146697437',
    //     'day_change_percent': -0.25,
    //     'week_change_percent': -0.8,
    //     'tradingview_symbol': 'BINANCE:BTCUSDT',
    //     'liked_by_user': false,
    // },
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketType interface{} = "spot"
    var marketId interface{} = this.SafeString(ticker, "id")
    var marketinfo interface{} = this.Market(marketId)
    var symbol interface{} = this.SafeSymbol(marketId, market, nil, marketType)
    var high interface{} = this.SafeFloat(ticker, "max_price", 0)
    var low interface{} = this.SafeFloat(ticker, "min_price", 0)
    var bid interface{} = this.SafeFloat(ticker, "min_price", 0)
    var ask interface{} = this.SafeFloat(ticker, "max_price", 0)
    var open interface{} = this.SafeFloat(ticker, "last_price", 0)
    var close interface{} = this.SafeFloat(ticker, "last_price", 0)
    var change interface{} = this.SafeFloat(ticker, "day_change_percent", 0)
    var last interface{} = this.SafeFloat(ticker, "last_price", 0)
    var quoteVolume interface{} = this.SafeFloat(ticker, "last_volume", 0)
    if IsTrue(IsEqual(GetValue(marketinfo, "quote"), "IRT")) {
        high = Ternary(IsTrue(high), Divide(high, 10), 0)
        low = Ternary(IsTrue(low), Divide(low, 10), 0)
        bid = Ternary(IsTrue(bid), Divide(bid, 10), 0)
        ask = Ternary(IsTrue(ask), Divide(ask, 10), 0)
        open = Ternary(IsTrue(open), Divide(open, 10), 0)
        close = Ternary(IsTrue(close), Divide(close, 10), 0)
        last = Ternary(IsTrue(last), Divide(last, 10), 0)
        quoteVolume = Ternary(IsTrue(quoteVolume), Divide(quoteVolume, 10), 0)
    }
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": nil,
        "datetime": nil,
        "high": high,
        "low": low,
        "bid": bid,
        "bidVolume": nil,
        "ask": ask,
        "askVolume": nil,
        "vwap": nil,
        "open": open,
        "close": close,
        "last": last,
        "previousClose": nil,
        "change": change,
        "percentage": nil,
        "average": nil,
        "baseVolume": nil,
        "quoteVolume": quoteVolume,
        "info": ticker,
    }, market)
}
func  (this *bitir) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    /**
            * @method
            * @name bitir#fetchOHLCV
            * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
            * @see https://www.bit.ir/fa
            * @param {string} symbol unified symbol of the market to fetch OHLCV data for
            * @param {string} timeframe the length of time each candle represents
            * @param {int} [since] timestamp in ms of the earliest candle to fetch
            * @param {int} [limit] the maximum amount of candles to fetch
            * @param {object} [params] extra parameters specific to the exchange API endpoint
            * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
            */
            timeframe := GetArg(optionalArgs, 0, "1h")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes4238 := (<-this.LoadMarkets())
            PanicOnError(retRes4238)
            var market interface{} = this.Market(symbol)
            symbol = Add(GetValue(market, "base"), GetValue(market, "quote"))
            if IsTrue(IsEqual(GetValue(market, "quote"), "IRT")) {
                symbol = Add(GetValue(market, "base"), "IRR")
            }
            var endTime interface{} = DateNow()
            var request interface{} = map[string]interface{} {
                "symbol": symbol,
                "from": Subtract((Divide(endTime, 1000)), (Multiply(Multiply(24, 60), 60))),
                "to": Divide(endTime, 1000),
                "resolution": this.SafeString(this.Timeframes, timeframe, timeframe),
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "from", Divide(since, 1000))
            }
            AddElementToObject(request, "from", this.SafeInteger(request, "from"))
            AddElementToObject(request, "to", this.SafeInteger(request, "to"))
            if IsTrue(!IsEqual(timeframe, nil)) {
                AddElementToObject(request, "resolution", this.SafeString(this.Timeframes, timeframe, timeframe))
            }
        
            response:= (<-this.PublicGetV2UdfRealHistory(request))
            PanicOnError(response)
            var openList interface{} = this.SafeValue(response, "o", []interface{}{})
            var highList interface{} = this.SafeList(response, "h", []interface{}{})
            var lowList interface{} = this.SafeList(response, "l", []interface{}{})
            var closeList interface{} = this.SafeList(response, "c", []interface{}{})
            var volumeList interface{} = this.SafeList(response, "v", []interface{}{})
            var timestampList interface{} = this.SafeList(response, "t", []interface{}{})
            var ohlcvs interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(openList)); i++ {
                if IsTrue(IsEqual(GetValue(market, "quote"), "IRT")) {
                    AddElementToObject(openList, i, Ternary(IsTrue(GetValue(openList, i)), Divide(GetValue(openList, i), 10), 0))
                    AddElementToObject(highList, i, Ternary(IsTrue(GetValue(highList, i)), Divide(GetValue(highList, i), 10), 0))
                    AddElementToObject(lowList, i, Ternary(IsTrue(GetValue(lowList, i)), Divide(GetValue(lowList, i), 10), 0))
                    AddElementToObject(closeList, i, Ternary(IsTrue(GetValue(closeList, i)), Divide(GetValue(closeList, i), 10), 0))
                    AddElementToObject(volumeList, i, Ternary(IsTrue(GetValue(volumeList, i)), Divide(GetValue(volumeList, i), 10), 0))
                }
                AppendToArray(&ohlcvs, []interface{}{GetValue(timestampList, i), GetValue(openList, i), GetValue(highList, i), GetValue(lowList, i), GetValue(closeList, i), GetValue(volumeList, i)})
            }
        
            ch <- this.ParseOHLCVs(ohlcvs, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *bitir) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    /**
            * @method
            * @name bitir#fetchOrderBooks
            * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data for multiple markets
            * @see https://www.bit.ir/fa
            * @param {string[]|undefined} symbols list of unified market symbols, all symbols fetched if undefined, default is undefined
            * @param {int} [limit] max number of entries per orderbook to return, default is undefined
            * @param {object} [params] extra parameters specific to the exchange API endpoint
            * @returns {object} a dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbol
            */
            limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes4838 := (<-this.LoadMarkets())
            PanicOnError(retRes4838)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "id": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetV1MarketIdOrder(request))
            PanicOnError(response)
            var orderbookList interface{} = this.SafeList(response, "data")
            var orberbook interface{} = map[string]interface{} {
                "asks": []interface{}{},
                "bids": []interface{}{},
            }
            for i := 0; IsLessThan(i, GetArrayLength(orderbookList)); i++ {
                var orderType interface{} = this.SafeString(GetValue(orderbookList, i), "type")
                var price interface{} = this.SafeFloat(GetValue(orderbookList, i), "price", 0)
                var amount interface{} = this.SafeFloat(GetValue(orderbookList, i), "amount", 0)
                if IsTrue(IsEqual(orderType, "sell")) {
                    if IsTrue(IsEqual(GetValue(market, "quote"), "IRT")) {
                        price = Divide(price, 10)
                    }
                    retRes49916 := GetValue(orberbook, "asks")
                    AppendToArray(&retRes49916, []interface{}{price, amount})
                }
                if IsTrue(IsEqual(orderType, "buy")) {
                    if IsTrue(IsEqual(GetValue(market, "quote"), "IRT")) {
                        price = Divide(price, 10)
                    }
                    retRes50516 := GetValue(orberbook, "bids")
                    AppendToArray(&retRes50516, []interface{}{price, amount})
                }
            }
            var timestamp interface{} = DateNow()
        
            ch <- this.ParseOrderBook(orberbook, symbol, timestamp)
            return nil
        
            }()
            return ch
        }
func  (this *bitir) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var query interface{} = this.Omit(params, this.ExtractParams(path))
    var url interface{} = Add(Add(GetValue(GetValue(this.Urls, "api"), "public"), "/"), path)
    if IsTrue(IsTrue(IsEqual(path, "v1/market")) && IsTrue(!IsEqual(GetValue(params, "id"), nil))) {
        url = Add(Add(url, "/"), GetValue(params, "id"))
    }
    if IsTrue(IsEqual(path, "v2/udf/real/history")) {
        url = Add(Add(url, "?"), this.Urlencode(query))
    }
    if IsTrue(IsEqual(path, "v1/market/{id}/order")) {
        url = Add(Add(Add(GetValue(GetValue(this.Urls, "api"), "public"), "/v1/market/"), GetValue(params, "id")), "/order")
    }
    headers = map[string]interface{} {
        "Content-Type": "application/json",
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}


func (this *bitir) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.DerivedExchange = this
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
}
